const { 
    SlashCommandBuilder, 
    PermissionFlagsBits, 
    ChannelType,
    MessageFlags
} = require('discord.js');

module.exports = {
    guildOnly: true,
    data: new SlashCommandBuilder()
        .setName('copyserver')
        .setDescription('Wipes THIS server and copies data from a Source Server ID.')
        .addStringOption(option => 
            option.setName('source_id')
                .setDescription('The ID of the server to copy FROM')
                .setRequired(true)
        )
        .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

    async execute(interaction) {
        const sourceId = interaction.options.getString('source_id');
        const targetGuild = interaction.guild;
        const sourceGuild = interaction.client.guilds.cache.get(sourceId);

        // --- CHECKS ---
        if (!sourceGuild) {
            return interaction.reply({ 
                content: `âŒ **Source not found.**\nI must be inside the server with ID \`${sourceId}\` to copy it.`, 
                flags: MessageFlags.Ephemeral 
            });
        }

        if (targetGuild.id === sourceGuild.id) {
            return interaction.reply({ content: 'âŒ Cannot replicate a server onto itself.', flags: MessageFlags.Ephemeral });
        }

        // --- SAFETY CONFIRMATION ---
        await interaction.reply({ 
            content: `âš ï¸ **WARNING:** This will **DELETE ALL** channels and roles in **${targetGuild.name}**.\n\nCreating "cloning-logs" channel in 3 seconds...`,
            flags: MessageFlags.Ephemeral
        });
        
        const wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        await wait(3000);

        try {
            // 1. Create a "Safe Room" channel
            // We do this FIRST so we have a place to talk while everything else is deleted
            const logChannel = await targetGuild.channels.create({
                name: 'cloning-logs',
                type: ChannelType.GuildText,
                reason: 'Replication Log Channel'
            });

            // Notify user to move there
            await interaction.followUp({ 
                content: `âœ… **Process Started.**\nPlease go to <#${logChannel.id}> to watch the progress.`, 
                flags: MessageFlags.Ephemeral 
            });

            await logChannel.send('ðŸ”„ **Wiping Server...** (This keeps me alive)');

            // 2. DELETE OLD DATA (Excluding the Log Channel)
            const channelsToDelete = targetGuild.channels.cache.filter(c => c.id !== logChannel.id && c.deletable);
            for (const [id, channel] of channelsToDelete) {
                await channel.delete().catch(() => {});
            }

            const rolesToDelete = targetGuild.roles.cache.filter(r => !r.managed && r.name !== '@everyone' && r.editable);
            for (const [id, role] of rolesToDelete) {
                await role.delete().catch(() => {});
            }

            await logChannel.send('ðŸ”„ **Copying Roles...**');

            // 3. COPY ROLES
            const roleMap = new Map();
            // Sort Low -> High position
            const rolesToCopy = sourceGuild.roles.cache
                .filter(r => !r.managed && r.name !== '@everyone')
                .sort((a, b) => a.position - b.position);

            for (const [oldId, role] of rolesToCopy) {
                try {
                    const newRole = await targetGuild.roles.create({
                        name: role.name,
                        color: role.color,
                        permissions: role.permissions,
                        hoist: role.hoist,
                        mentionable: role.mentionable
                    });
                    roleMap.set(oldId, newRole.id);
                    await wait(800); // Prevent Rate Limits
                } catch (e) {
                    await logChannel.send(`âš ï¸ Skip Role: ${role.name}`);
                }
            }
            roleMap.set(sourceGuild.id, targetGuild.id); // Map @everyone

            // Helper for Permissions
            const getOverwrites = (channel) => {
                return channel.permissionOverwrites.cache.map(overwrite => {
                    const newId = roleMap.get(overwrite.id);
                    if (!newId) return null;
                    return {
                        id: newId,
                        allow: overwrite.allow,
                        deny: overwrite.deny,
                        type: overwrite.type
                    };
                }).filter(o => o !== null);
            };

            // 4. COPY CATEGORIES
            await logChannel.send('ðŸ”„ **Copying Categories...**');
            const categoryMap = new Map();
            const categories = sourceGuild.channels.cache
                .filter(c => c.type === ChannelType.GuildCategory)
                .sort((a, b) => a.position - b.position);

            for (const [oldId, cat] of categories) {
                try {
                    const newCat = await targetGuild.channels.create({
                        name: cat.name,
                        type: ChannelType.GuildCategory,
                        permissionOverwrites: getOverwrites(cat)
                    });
                    categoryMap.set(oldId, newCat.id);
                    await wait(800);
                } catch (e) {}
            }

            // 5. COPY CHANNELS
            await logChannel.send('ðŸ”„ **Copying Channels...**');
            const channels = sourceGuild.channels.cache
                .filter(c => c.type !== ChannelType.GuildCategory && c.type !== ChannelType.GuildDirectory)
                .sort((a, b) => a.position - b.position);

            for (const [oldId, channel] of channels) {
                try {
                    const newParent = channel.parentId ? categoryMap.get(channel.parentId) : null;
                    await targetGuild.channels.create({
                        name: channel.name,
                        type: channel.type,
                        parent: newParent,
                        topic: channel.topic,
                        nsfw: channel.nsfw,
                        permissionOverwrites: getOverwrites(channel)
                    });
                    await wait(1000);
                } catch (e) {
                    console.log(`Failed channel: ${channel.name}`);
                }
            }

            // 6. FINISH
            await logChannel.send(`âœ… **Replication Complete!**\nEverything has been copied from **${sourceGuild.name}**.\n\n*You can delete this channel now.*`);

        } catch (error) {
            console.error(error);
        }
    }
};
